//
// This file generated by rdl 1.4.12
//

package hello

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"strings"

	rdl "github.com/ardielle/ardielle-go/rdl"
	"github.com/dimfeld/httptreemux"
)

var _ = json.Marshal
var _ = ioutil.Discard

//
// Init initializes the Hello server with a service identity and an
// implementation (HelloHandler), and returns an http.Handler to serve it.
//
func Init(impl HelloHandler, baseURL string, authz rdl.Authorizer, authns ...rdl.Authenticator) http.Handler {
	for strings.HasSuffix(baseURL, "/") {
		baseURL = baseURL[0 : len(baseURL)-1]
	}
	u, err := url.Parse(baseURL)
	if err != nil {
		log.Fatal(err)
	}
	b := u.Path
	router := httptreemux.New()
	adaptor := HelloAdaptor{impl, authz, authns, b}

	router.GET(b+"/greeting", func(w http.ResponseWriter, r *http.Request, ps map[string]string) {
		adaptor.getGreetingHandler(w, r, ps)
	})
	router.NotFoundHandler = func(w http.ResponseWriter, r *http.Request) {
		rdl.JSONResponse(w, 404, rdl.ResourceError{Code: http.StatusNotFound, Message: "Not Found"})
	}
	log.Printf("Initialized Hello service at '%s'\n", baseURL)
	return router
}

//
// HelloHandler is the interface that the service implementation must conform to
//
type HelloHandler interface {
	GetGreeting(context *rdl.ResourceContext, name string) (*Greeting, error)
	Authenticate(context *rdl.ResourceContext) bool
}

//
// HelloAdaptor - this adapts the http-oriented router calls to the non-http service handler.
//
type HelloAdaptor struct {
	impl           HelloHandler
	authorizer     rdl.Authorizer
	authenticators []rdl.Authenticator
	endpoint       string
}

func (adaptor HelloAdaptor) authenticate(context *rdl.ResourceContext) bool {
	if adaptor.authenticators != nil {
		for _, authn := range adaptor.authenticators {
			var creds []string
			var ok bool
			header := authn.HTTPHeader()
			if strings.HasPrefix(header, "Cookie.") {
				if cookies, ok2 := context.Request.Header["Cookie"]; ok2 {
					prefix := header[7:] + "="
					for _, c := range cookies {
						if strings.HasPrefix(c, prefix) {
							creds = append(creds, c[len(prefix):])
							ok = true
							break
						}
					}
				}
			} else {
				creds, ok = context.Request.Header[header]
			}
			if ok && len(creds) > 0 {
				principal := authn.Authenticate(creds[0])
				if principal != nil {
					context.Principal = principal
					return true
				}
			}
		}
	}
	if adaptor.impl.Authenticate(context) {
		return true
	}
	log.Println("*** Authentication failed against all authenticator(s)")
	return false
}

func (adaptor HelloAdaptor) authorize(context *rdl.ResourceContext, action string, resource string) bool {
	if adaptor.authorizer == nil {
		return true
	}
	if !adaptor.authenticate(context) {
		return false
	}
	ok, err := adaptor.authorizer.Authorize(action, resource, context.Principal)
	if err == nil {
		return ok
	}
	log.Println("*** Error when trying to authorize:", err)
	return false
}

func intFromString(s string) int64 {
	var n int64 = 0
	_, _ = fmt.Sscanf(s, "%d", &n)
	return n
}

func floatFromString(s string) float64 {
	var n float64 = 0
	_, _ = fmt.Sscanf(s, "%g", &n)
	return n
}

func (adaptor HelloAdaptor) getGreetingHandler(writer http.ResponseWriter, request *http.Request, params map[string]string) {
	context := &rdl.ResourceContext{Writer: writer, Request: request, Params: params, Principal: nil}
	argName, _ := rdl.StringParam(request, "sender", "human")
	data, err := adaptor.impl.GetGreeting(context, argName)
	if err != nil {
		switch e := err.(type) {
		case *rdl.ResourceError:
			rdl.JSONResponse(writer, e.Code, err)
		default:
			rdl.JSONResponse(writer, 500, &rdl.ResourceError{Code: 500, Message: e.Error()})
		}
	} else {
		rdl.JSONResponse(writer, 200, data)
	}

}
